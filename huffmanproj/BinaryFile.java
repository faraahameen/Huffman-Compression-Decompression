/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package huffmanproj;

/**
 *
 * @author Farah ameen
 */


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;

public class BinaryFile {
 // Strings of 1s and 0s which are mapped by a string
    public HashMap< Byte, Integer> binaryMap = new HashMap<>();
    // the string generated by compression is changed to 1's and 0's and mapped to original byte
    public HashMap<Byte, String> compressCodes = new HashMap<>();
    // takes the strings generated by compression and map it to a bytes of 0's and 1's
    public HashMap<String, Byte> decompressMap = new HashMap<>();

    public class BinaryNode {

        private int value;
        private byte bytes;
        private BinaryNode left = null;
        private BinaryNode right = null;

        public BinaryNode(int freq, BinaryNode left, BinaryNode right) {
            this.value = freq;
            this.left = left;
            this.right = right;

        }

        public BinaryNode() {

        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }

        public void setByte(byte bytes) {
            this.bytes = bytes;
        }

        public byte getByte() {
            return bytes;
        }

        public void setLeft(BinaryNode left) {
            this.left = left;
        }

        public void setRight(BinaryNode right) {
            this.right = right;
        }

        public BinaryNode getLeft() {
            return left;
        }

        public BinaryNode getRight() {
            return right;
        }

        public boolean isLeftNull() {
            if (this.left == null) {
                return true;
            } else {
                return false;
            }
        }

        public boolean isRightNull() {
            if (this.right == null) {
                return true;
            } else {
                return false;
            }
        }
    }

    BinaryNode bn = new BinaryNode();
    public PriorityQueue<BinaryNode> pq = new PriorityQueue<>(new Comparator<BinaryNode>() {
           // compare frequencies of the 2 nodes
        public int compare(BinaryNode n1, BinaryNode n2) {
            if (n1.getValue() < n2.getValue()) {
                return -1;
            }
            if (n1.getValue() > n2.getValue()) {
                return 1;
            }
            return 0;
        }
    });

    public void read() {

        String fileName = "input.pdf";
        File file = new File(fileName);
         //FileInputStream obtains input bytes from a file
        FileInputStream stream = null;
        try {
            stream = new FileInputStream(file);
            byte fileContent[] = new byte[(int) file.length()];
            // read file contents
            stream.read(fileContent);
            //intialize frequency by 1
            int frequency = 1;
            //for each byte in file content
            for (byte Byte : fileContent) {
                if (binaryMap.containsKey(Byte)) {
                    frequency = binaryMap.get(Byte) + 1;
                    binaryMap.put(Byte, frequency);
                } else {
                    binaryMap.put(Byte, 1);
                }
            }
        } catch (FileNotFoundException ex) {
            System.out.println("Can't find file" + fileName);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public void insertToHeap() {
        for (byte key : binaryMap.keySet()) {
            BinaryNode node = new BinaryNode();
            node.setValue(binaryMap.get(key));
            node.setByte(key);
            pq.add(node);
        }

    }

    public BinaryNode buildHuffmanTree() {
        while (pq.size() != 1) {
            BinaryNode left = pq.poll();
            BinaryNode right = pq.poll();
            BinaryNode n = new BinaryNode(left.getValue() + right.getValue(), left, right);
            pq.add(n);
        }
        return pq.poll();
    }

    public void getCodes(BinaryNode root, String code) {
        if (root == null) {
            return;
        }

        if (root.isLeftNull() && root.isRightNull()) {
            compressCodes.put(root.getByte(), code);
        }
        if (!root.isLeftNull() && !root.isRightNull()) {

            getCodes(root.getLeft(), code + "0");
            getCodes(root.getRight(), code + "1");
        }
    }

    public int getCodeSize() {
        int size = 0;
        for (byte key : compressCodes.keySet()) {
            size += compressCodes.get(key).length() * binaryMap.get(key);
        }
        return size;
    }

    public void compress() {
        String inputFile = "input.pdf";
        String outputFile = "compressed";
        File file = new File(inputFile);
        File file2 = new File(outputFile);
        FileInputStream stream2 = null;
        FileOutputStream stream = null;
        //start compressing at this point
        read();
        insertToHeap();
        BinaryNode root = buildHuffmanTree();
        getCodes(root, "");
        //compress
        try {
            stream = new FileOutputStream(outputFile);
            stream2 = new FileInputStream(inputFile);
            try {
                //saving huffman codes in the header
                //get the codesize
                byte[] CodeSize = ByteBuffer.allocate(4).putInt(getCodeSize()).array();
                stream.write(CodeSize);
                 //array of 4 bytes
                //get mapsize: # of key,value pairs
                byte[] mapSizeBytes = ByteBuffer.allocate(4).putInt(compressCodes.size()).array();
                stream.write(mapSizeBytes);
                for (byte key : compressCodes.keySet()) {
                    stream.write(key);
                    byte[] sizeBytes = ByteBuffer.allocate(4).putInt(compressCodes.get(key).length()).array();
                    stream.write(sizeBytes);
                    byte[] codeBytes = compressCodes.get(key).getBytes();
                    stream.write(codeBytes);
                    //   System.out.println(key + "= " +  codesMap.get(key));
                }
                //saving compressed file
                String code = new String();
                byte fileContent[] = new byte[(int) file.length()];
                stream2.read(fileContent);
                int frequency = 1;
                //for each byte in the file contents
                for (byte charbyte : fileContent) {
                    // compress codes get string value for the byte
                    code += compressCodes.get(charbyte);
                    if (code.length() % 8 == 0 && code.length() != 0) {
                        int length = code.length();
                        byte[] bytes = new byte[(length + Byte.SIZE - 1) / Byte.SIZE];
                        char character;
                        for (int i = 0; i < length; i++) {
                            if ((character = code.charAt(i)) == '1') {
                                 // we will OR (bytes[i / Byte.SIZE] BY (0x80 >>> (i % Byte.SIZE)) for bit masking
                                //Bitwise shift because we are dealing with a sequence of bits not a number
                                bytes[i / Byte.SIZE] = (byte) (bytes[i / Byte.SIZE] | (0x80 >>> (i % Byte.SIZE)));
                            }
                        }
                        stream.write(bytes);
                        code = "";
                    }

                }
                if (code.length() != 0) {
                    int length = code.length();
                    byte[] bytes = new byte[(length + Byte.SIZE - 1) / Byte.SIZE];
                    char character;
                    int i = 0;
                    while (i < length) {
                        if ((character = code.charAt(i)) == '1') {
                                 // we will OR (bytes[i / Byte.SIZE] BY (0x80 >>> (i % Byte.SIZE)) for bit masking
                                //Bitwise shift because we are dealing with a sequence of bits not a number
                            bytes[i / Byte.SIZE] = (byte) (bytes[i / Byte.SIZE] | (0x80 >>> (i % Byte.SIZE)));
                        }
                        i++;
                    }
                    stream.write(bytes);
                    code = "";
                    System.out.println("File is successfully compressed");
                }

                stream.close();
            } catch (FileNotFoundException ex) {
                System.out.println("File can't be open " + outputFile + "'");
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        } catch (FileNotFoundException ex) {
            System.out.println("File can't be open " + inputFile + "'");
        }
    }

    public void decompress() {
        String inputFile = "compressed";
        String outputFile = "decompressed";
        File file = new File(inputFile);
        FileInputStream stream = null;
        FileOutputStream stream2 = null;
        int i, j, m, size, n, y;
        byte c = 0;
        try {
            stream = new FileInputStream(inputFile);
            stream2 = new FileOutputStream(outputFile);
            byte fileContent[] = new byte[(int) file.length()];
            stream.read(fileContent);
            stream.close();
            String s = new String();
            int sizeOfCode, sizeOfMap;
            for (i = 0; i < 4; i++) {
                s += String.format("%02x", fileContent[i]);
            }
            sizeOfCode = Integer.parseInt(s, 16);
            s = "";
            for (j = i; j < i + 4; j++) {
                s += String.format("%02x", fileContent[j]);
            }
            sizeOfMap = Integer.parseInt(s, 16);
            s = "";
            int count = j;
            int k = 0;
            while (k < sizeOfMap) {
                c = fileContent[count];
                count++;
                for (m = count; m < count + 4; m++) {
                    s += String.format("%02x", fileContent[m]);
                }
                size = Integer.parseInt(s, 16);
                s = "";
                String code = new String();
                n=m;
                while(n < m + size) {
                    code += (char) fileContent[n];
                    n++;
                }
                decompressMap.put(code, c);
                count = n;
                k++;
            }
            s = "";
            try {
                String decode = "";
                int index = 0, taken = 0;
                for (y = count; y < fileContent.length; y++) {
                    s += String.format("%8s", Integer.toBinaryString(fileContent[y] & 0xFF)).replace(' ', '0');
                    int z = 0;
                    while (z < s.length()) {
                        decode += s.charAt(z);
                        if (decompressMap.containsKey(decode)) {
                            taken += decode.length();
                            if (taken <= sizeOfCode) {
                                stream2.write(decompressMap.get(decode));
                                decode = "";
                                index = z;
                            }
                        }
                        z++;
                    }
                    if (index != 0) {
                        s = s.substring(index + 1, s.length());
                        index = 0;
                    }
                    decode = "";

                }
                stream2.close();
                System.out.println("File is successfully decompressed");
            } catch (FileNotFoundException ex) {
                System.out.println("Can't find file " + outputFile);
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        } catch (FileNotFoundException ex) {
            System.out.println("Can't find file " + inputFile);
        } catch (IOException ex) {
            ex.printStackTrace();
        }

    }

}

